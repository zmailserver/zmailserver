/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Server
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013 VMware, Inc.
 * 
 * The contents of this file are subject to the Zimbra Public License
 * Version 1.3 ("License"); you may not use this file except in
 * compliance with the License.  You may obtain a copy of the License at
 * http://www.zimbra.com/license.
 * 
 * Software distributed under the License is distributed on an "AS IS"
 * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * ***** END LICENSE BLOCK *****
 */

package org.zmail.cs.service.mail;

import java.util.ArrayList;
import java.util.EnumSet;
import java.util.List;
import java.util.Map;

import com.google.common.base.Strings;
import com.google.common.io.Closeables;
import org.zmail.common.account.Key.AccountBy;
import org.zmail.common.localconfig.LC;
import org.zmail.common.service.ServiceException;
import org.zmail.common.soap.Element;
import org.zmail.common.soap.MailConstants;
import org.zmail.common.soap.SoapFaultException;
import org.zmail.common.util.ZmailLog;
import org.zmail.cs.account.Account;
import org.zmail.cs.account.Provisioning;
import org.zmail.cs.index.SearchParams;
import org.zmail.cs.index.SearchParams.ExpandResults;
import org.zmail.cs.index.SortBy;
import org.zmail.cs.index.ZmailHit;
import org.zmail.cs.index.ZmailQueryResults;
import org.zmail.cs.mailbox.Conversation;
import org.zmail.cs.mailbox.Flag;
import org.zmail.cs.mailbox.MailItem;
import org.zmail.cs.mailbox.Mailbox;
import org.zmail.cs.mailbox.Message;
import org.zmail.cs.mailbox.OperationContext;
import org.zmail.cs.service.util.ItemId;
import org.zmail.cs.service.util.ItemIdFormatter;
import org.zmail.cs.session.PendingModifications.Change;
import org.zmail.soap.ZmailSoapContext;

/**
 * @since Nov 30, 2004
 */
public final class SearchConv extends Search {

    private static final int CONVERSATION_FIELD_MASK = Change.SIZE | Change.TAGS | Change.FLAGS;

    @Override
    public Element handle(Element request, Map<String, Object> context) throws ServiceException {
        ZmailSoapContext zsc = getZmailSoapContext(context);
        Mailbox mbox = getRequestedMailbox(zsc);
        OperationContext octxt = getOperationContext(zsc, context);
        ItemIdFormatter ifmt = new ItemIdFormatter(zsc);
        boolean nest = request.getAttributeBool(MailConstants.A_NEST_MESSAGES, false);
        Account acct = getRequestedAccount(zsc);
        SearchParams params = SearchParams.parse(request, zsc, acct.getPrefMailInitialSearch());

        // append (conv:(convid)) onto the beginning of the queryStr
        ItemId cid = new ItemId(request.getAttribute(MailConstants.A_CONV_ID), zsc);
        params.setQueryString("conv:\"" + cid.toString(ifmt) + "\" (" + params.getQueryString() + ')');

        // force to group-by-message
        params.setTypes(EnumSet.of(MailItem.Type.MESSAGE));

        Element response = null;
        if (cid.belongsTo(mbox)) { // local
            ZmailQueryResults results =  mbox.index.search(zsc.getResponseProtocol(), octxt, params);
            try {
                response = zsc.createElement(MailConstants.SEARCH_CONV_RESPONSE);
                response.addAttribute(MailConstants.A_QUERY_OFFSET, Integer.toString(params.getOffset()));

                SortBy sort = results.getSortBy();
                response.addAttribute(MailConstants.A_SORTBY, sort.toString());

                List<Message> msgs = mbox.getMessagesByConversation(octxt, cid.getId(), sort, -1);
                if (msgs.isEmpty() && zsc.isDelegatedRequest()) {
                    throw ServiceException.PERM_DENIED("you do not have sufficient permissions");
                }

                // filter out IMAP \Deleted messages from the message lists
                Conversation conv = mbox.getConversationById(octxt, cid.getId());
                if (conv.isTagged(Flag.FlagInfo.DELETED)) {
                    List<Message> raw = msgs;
                    msgs = new ArrayList<Message>();
                    for (Message msg : raw) {
                        if (!msg.isTagged(Flag.FlagInfo.DELETED)) {
                            msgs.add(msg);
                        }
                    }
                }

                Element container = nest ? ToXML.encodeConversationSummary(
                        response, ifmt, octxt, conv, CONVERSATION_FIELD_MASK): response;
                SearchResponse builder = new SearchResponse(zsc, octxt, container, params);
                builder.setAllRead(conv.getUnreadCount() == 0);

                boolean more = putHits(octxt, ifmt, builder, msgs, results, params);
                response.addAttribute(MailConstants.A_QUERY_MORE, more);

                // call me AFTER putHits since some of the <info> is generated by the getting of the hits!
                builder.add(results.getResultInfo());
            } finally {
                Closeables.closeQuietly(results);
            }

            return response;

        } else { // remote
            Element proxyRequest = zsc.createElement(MailConstants.SEARCH_CONV_REQUEST);

            params.encodeParams(proxyRequest);
            proxyRequest.addAttribute(MailConstants.A_NEST_MESSAGES, nest);
            proxyRequest.addAttribute(MailConstants.A_CONV_ID, cid.toString());


            try {
                // okay, lets run the search through the query parser -- this has the side-effect of
                // re-writing the query in a format that is OK to proxy to the other server -- since the
                // query has an "AND conv:remote-conv-id" part, the query parser will figure out the right
                // format for us.  TODO somehow make this functionality a bit more exposed in the
                // ZmailQuery APIs...
                String rewrittenQueryString = mbox.getRewrittenQueryString(octxt, params);
                proxyRequest.addAttribute(MailConstants.E_QUERY, rewrittenQueryString, Element.Disposition.CONTENT);

                // proxy to remote account
                Account target = Provisioning.getInstance().get(AccountBy.id, cid.getAccountId(), zsc.getAuthToken());
                response = proxyRequest(proxyRequest, context, target.getId());
                return response.detach();
            } catch (SoapFaultException e) {
                throw ServiceException.FAILURE("SoapFaultException: ", e);
            }
        }
    }

    /**
     * This will only work for messages. That's OK since we force
     * GROUP_BY_MESSAGE here.
     *
     * @param octxt operation context
     * @param el SOAP container to put response data in
     * @param msgs list of messages in this conversation
     * @param results set of HITS for messages in this conversation which
     *  matches the search
     * @param offset offset in conversation to start at
     * @param limit number to return
     * @return whether there are more messages in the conversation past
     *  the specified limit
     * @throws ServiceException
     */
    private boolean putHits(OperationContext octxt, ItemIdFormatter ifmt, SearchResponse resp, List<Message> msgs,
            ZmailQueryResults results, SearchParams params)
    throws ServiceException {

        int offset = params.getOffset();
        int limit = params.getLimit();
        int size = msgs.size() <= limit + offset ? msgs.size() - offset : limit;

        if (size > 0) {
            // Array of ZmailHit ptrs for matches, 1 entry for every message
            // we might return from conv. NULL means no ZmailHit presumably b/c the message didn't match the search.
            // Note that the match for msgs[i] is matched[i-offset]!!!!
            ZmailHit[] matched = new ZmailHit[size];
            // For each hit, see if the hit message is in this conv (msgs).
            while (results.hasNext()) {
                ZmailHit hit = results.getNext();
                // we only bother checking the messages between offset and offset + size,
                // since only they are getting returned.
                for (int i = offset; i < offset + size; i++) {
                    if (hit.getParsedItemID().equals(new ItemId(msgs.get(i)))) {
                        matched[i - offset] = hit;
                        break;
                    }
                }
            }

            // Okay, we've built the matched[] array. Now iterate through all the messages, and put the message or
            // the MATCHED entry into the result
            for (int i = offset; i < offset + size; i++) {
                if (matched[i - offset] != null) {
                    resp.add(matched[i - offset]);
                } else {
                    Message msg = msgs.get(i);
                    ExpandResults expand = params.getInlineRule();
                    boolean inline = expand == ExpandResults.ALL || expand.matches(msg);
                    addMessageMiss(msg, resp.toElement(), octxt, ifmt, inline, params);
                }
            }
        }

        return offset + size < msgs.size();
    }

    private Element addMessageMiss(Message msg, Element response, OperationContext octxt, ItemIdFormatter ifmt,
            boolean inline, SearchParams params) throws ServiceException {

        // for bug 7568, mark-as-read must happen before the response is encoded.
        if (inline && msg.isUnread() && params.getMarkRead()) {
            // Mark the message as READ
            try {
                msg.getMailbox().alterTag(octxt, msg.getId(), msg.getType(), Flag.FlagInfo.UNREAD, false, null);
            } catch (ServiceException e) {
                ZmailLog.search.warn("problem marking message as read (ignored): %d", msg.getId(), e);
            }
        }

        Element el;
        if (inline) {
            el = ToXML.encodeMessageAsMP(response, ifmt, octxt, msg, null, params.getMaxInlinedLength(),
                    params.getWantHtml(), params.getNeuterImages(), null, true, params.getWantExpandGroupInfo(), LC.mime_encode_missing_blob.booleanValue());
            if (!Strings.isNullOrEmpty(msg.getFragment())) {
                el.addAttribute(MailConstants.E_FRAG, msg.getFragment(), Element.Disposition.CONTENT);
            }
        } else {
            el = ToXML.encodeMessageSummary(response, ifmt, octxt, msg, params.getWantRecipients(), ToXML.NOTIFY_FIELDS);
        }
        return el;
    }

}
